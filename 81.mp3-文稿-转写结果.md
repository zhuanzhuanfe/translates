In this episode of full stack radio, I talk to Evan You the creator of Vue.js about advanced component design concepts, and how you can use some of Vue's features like Scoped Slots, and Render Functions to create components that are a lot more than just UI widgets, this is full stack radio episode 81, Everyone welcome to another episode of the full stack radio pod cast. I'm your host Adam Wathan, and today it's my pleasure to be speaking again with Evan You the creator of Vue.js. Welcome back Evan. How's going? Good to be back. Yeah, it's good to have you back. Um, so the reason I want to have you back on the show is that I've been paying a little bit more attention to what's going on in some of the other uh communities around other JavaScript framework *since duff* trying to look for interesting things that people are doing that I can learn from figure out how to apply them with the work that I do on a daily basis with Vue.js and one of the um topics that people are really talking about a lot uh these days or at least I'm noticing it a lot more is stuff like higher order components and render props components and stuff in the react world. 
Uh, so I thought it would be interesting to sort of get your take on some of these ideas and talk about uh how they translate to Vue and the sorts of things that you can do with Vue to solve the same sorts of problems that people are trying to solve with those patterns. So maybe the best place to get started would just be to start of maybe get your take on what these ideas even are and what they're useful for. Um. So maybe we're starting with like higher order components. What is a higher order component when people are talking about it in the react world? And how do you solve those sorts of problems with Vue. 
So um, I think this this phrase is somewhat overloaded because I think there's a fair amount of misunderstanding of what they're really is. And I don't think there is a very like definitive like source of of like rolling basically the written down rules of what a higher component higher order component really is. Uh, but uh, the term higher order really comes from functional programming, where you have higher order functions. Um, it's just to put it in simple terms, I think it's just referring to composing another function using, uh, other function, composing one function out of other functions. So this, uh, final function would be calling other functions internally. So it kind of, uh, incorporates what the other functions do, but ah, add some extra functionally on top of it. 
Um. So higher order components, uh, was first sort of it first originated in react world mostly because react components are um, very close to functions. Right? The stateless functional components in react are just functions, ah, which means you can return another function right from what uh, another component from one component. Um, in in some sense, the simplest form of a higher order component is just a functional component. Their returns another component, uh, as its root node. Right? And any react, all the components are everything you pass. The components are just props. So when you, um, say have an internal component, and you want to essentially give this internal use this internal component, but uh, passing it some pre-defined props. 
Um, so you can you just create a wrapper component that returns this internal component, but at the same time passing it some props that's are already defined. So this is probably not a super useful example. But essentially what we're doing is just you created another interface for this internal component. In the end they render the same thing. But um when you use this outer wrap component, you no longer have to pass these additional props and yourself. Uh this rapid component is doing that word for you. Yeah. So It's kind of simplest. Um an example of a higher order component is really a conceptual the same as sort of like partial function application. Yeah. Yeah. It's actually very similar to that. So the other thing that I see people talking about that I Think is maybe like more interesting is the idea of components that except uh props that let you control what how that component should render before from like the outside right and people talk about these as being render prop components and I've seen people do similar things you know with what they call higher order components to. But I think the render prop ones are a little bit more interesting. So do you mind may be talking a little bit about that and what that looks like in Vue sure. Um so if you know how render functions work in Vue you'll know that um at very low level anything you can do and react you can apply in Vue just using render functions as well. 
Um, because other two into the two systems are when you are at the virtual down level, they are very similar, uh, in terms compose ability, uh, and render props in render props is more like so in react world render props are more straightforward in the sense that you are passing down a function as a prop. And that function will be called by the child component. And the child component will be passing some um, arguments to this function when it cause it. And this function's job is to return a virtual DOM structure, uh, which will be then composed with the child components own virtual DOM tree. 
Um, this essentially is allowing the child component to expose um, part of it's uh, virtual DOM tree to the parents allow the parent to decide what to render in those parts. Ah, at the same time, using some data that might that may be only the child component has access to. Right. And this looks very much like slots in a sense. Ah, and the difference from static slots that we are familiar with in Vue.js is that um, these slots are dynamic. They receive data from the child component. Yeah. So maybe before we any further be interesting to sort of like to talk about what normal slots I guess look like in Vue from a sense of what scope to have access to. Right. Like when you're building like a Vue component that has a child component that accepts slots, you can like pass mark up into that child component which will get render in the child component slot, but you only have access to like what exists in the scope of the parent. Right. Yeah. 
So and I think maybe something else I'd be interesting to talk about quickly before we move on is just giving like an example of a render prop component. So people sort of have an understanding and I think like the example that I originally saw that maybe is a good one to help people understand as like say you needed to have this behavior in your application of being able to track like the mouse position and there's different components in your app that all of them needed like access to the most position. And you're trying to come up with like a way to make that behavior sort of like more portable and reusable and give it like a single home. And what you do with like a render prop component at least in react is you might have a component called like uh tracks mouse or something. And it looks like a tag that you put into your markup. And inside of it you pass in like a render function now render function accepts the position of the mouse cursor and now the markup that you are returning from that function that you pass in has access to those. So it can make decisions about how it should render itself uh based on that data. So you get to keep all that logic about determining where the mouse is uh all isolated in this one like tracks mouse component. And you can use that to sort of compose all these other combinations of components. 
Ah, without re-implementing that logic or anything. And I think that's like what makes it really interesting anyways. Yeah, so it's essentially turning component so understanding component will how we typically use component, which is for a visual composition into some sort of logical composition where the component is not really are responsible for say uh rendering some visual structure but instead it's encapsulating some logic um and exposes the final data for you to decide how to actually render the visual parts. Yeah. And that's really interesting because I think a lot of people, especially people who are maybe new to Vue.js or who are only using it for uh, maybe simple use cases are only really do not really like I'm imagining some of the things that you could do when you think about like this idea of like components that only handle logic and don't handle temples. like everyone I think when they first can introduce this stuff, their mental model is like a component is like a widget on the screen that renders something. You know what I mean and I think that's kind of like the most interesting thing that I'd like to talk about in this conversation is just trying to talk about things that you can do besides just rendering a widget on the screen. It's sort of help people expand their imagination and figure out different things that they can do. So I'm to get back into what we're talking about. Um we're talking about slots. Right? So uh so we already sort of discussed with static slots are and how they work. 
Um, so scope slots, uh, In Vue.js I would say it's basically the equivalent of what render props are in react. Um, because us when you think about scopes lots, they are, um you have this slot scope um attribute in which you will receive the data that the child component passes to you. Um. So this is like the arguments that a function expects. Right? And the body of a scope slot is essentially uh if you're using render props, that's the JSX you're returning from the render props function. Yeah. And in there you have access to any data that got passed in through the slots scope, which is the equivalent to the parameters passed into a render prop. And you also have access to the parent scope, right? Which is pretty cool, because you can do some interesting things there. 
Yeah. I think the scoped slots components are something that are really easy to skim over in like the Vue documentation and not really recognize the power. So I'd be interested in hearing from you. Like, what are some examples may be starting with simple examples of things that you could do with scoped slots components. And then maybe we can get into some of the more interesting things that you could do with the scopes slots component. Sure. Um, so typically, the basic example that I usually give is when you're thinking about a list component right in the past. Um, so this kind of transitions from the still like thinking about components as official a composition unit, um, so if we build un really like basic list component, you would that this was component will be responsible for rendering everything inside of it. It will render, you know, maybe the UL elements that, uh, that wraps all these list items. And it would also render every list item inside of itself. So the styling, the structure, and everything both visual and logical are in, uh, encapsulated in inside this component, um, which makes it portable. But uh it's also less flexible because in a lot of cases, right, there are two parts of the list component that can potentially handle. Right? There is how each item and you know the layout, the CSS and how each item should eventually look. 
That's the visual side of it. And there's the logical side of it. For example, you might want to do make it a virtual scroll was component. You might want to implement infinite loading. You may want to have some nice functionality is like a when you scroll around there will be a little tool tips that's following you know all these kind of functionality that you might want to be able to reuse in multiple places. And you might want to have a generic this component that encapsulates virtual scrolling, infinite loading and other stuff. But um different places in your app, you might want the items to look different. 
Right? So now we have this problem because in in our first iteration, the logical side on the visual side of things are coupled in the same component. Yeah. So maybe to paint the picture here, like what is this component look like to use from the outside? If we're taking this sort of like basic naive approach, IT's like a tag that you have in your markup that maybe accepts the items as a prop. And that's what it looks like to use. Right? You have an opening tag, a closing tag, an access to items prop. From a consumer standpoint, you're done. Everything else is handled inside the component. Right? That's sort of the basic case that we're starting with exactly. 
So getting into the sort of a separation of like the logical elements and the kind of visual elements, what does that look like to separate them if you're trying to take advantage of like a scoped slot components approach. So let's say you want now you want to have say you implement this list component, you feel pretty good about it. We have all these advanced functionality is in it. But um, you use it in your main section. If your app may be displaying a list of a list of uh, projects. 
And now you implement another feature and you click in to the prop, you need to display a list of members who have contributed to this project. So you have this people list and each people item and each project item have completely different layouts. Right? So even the data source is different. So now you have the problem, because you basically hard coded the structure for projects in your previous list component. Now you want to reduce the logical part, but you want to change, um, change each item you want to now render people instead. Right? So, um, one naive way to do it is you just force the component, copy everything and change the part that renders the items. But that's obviously, you know, not reusing the stuff that you already did. So instead, you want to make each item customize a bowl by the consumer. Yeah. You basically you wanna figure out what's different between these and somehow make that like parameterize exactly right. So in Vue.js typically our props are just data, right? You only pass uh raw data of your props. Um, so uh the way you pass a visual structures down is using slots, but static slots doesn't really allow you to get access to data in the child scope. Right? So scoped slots kind of fills that gap uh in which the parent component is able to pass, um, visual structures, the you know the elements down into the child component. At the same time, the child component can uh, provide the parent with the necessary data to render each item. Yeah. So if you're trying to make like an analogy here or are trying to build a mental model of it, It's almost like the slot the scoped slot. It's like another prop, but it's like a layout prop or like a template prop. 
Yeah. So this prop uh is uh responsible for um returning. So right? Um, it's like returning JSX in render functions essentially. Yeah, I think that's really interesting. So if we were to think about like what this actually looks like and the code for this compared to the example they were talking about before, you have like the same sort of thing where you have like, um, maybe it's like an item list is the name of the component or whatever, and it has a items prop and you pass those items in. Um, but now instead of that having no content and just leaving all the logic and rendering up to the child components kind of internals, you'd have this extra tag inside of it that I guess in prior to some version, they have to be like template tags or something. But now I can just gonna be anything. So so maybe you have like a dive, and you'd have to, maybe it's a default slot, but it also be a name slot. Right? So say it would be like slot equals item, and this is the template that it should use for each item. And then you have this slot scope argument that would accept anything that the child component needs to give back to you. So maybe that's most simplest case is just giving you back each item kind of one at a time, and you can make a decision about how to render it. So now instead of having your people list on your projects list as like two duplicated components, you would just have this kind of generalized item list that handled all the shared logic between them and just that little different template about how they're supposed to how each item is supposed to look slightly different can just live where you use them. And if you wanted to I guess you could even bundle those up into their own components. Right? So you could still have a project list component and people as component, but internally they're like composed of this item list plus this just little piece of mark up the telephone between the two. Exactly. 
[广告]
So I think that's a really good simple example of how you might create a component that passes some data back to the parent uh but still does a bunch of rendering stuff on its own. But I've seen some more sort of advanced examples like the mouse one for example uh where that component doesn't actually render anything on its own at all. Uh so what does it look like in Vue to build a component like that that's responsible only for logic and doesn't actually provide any template of its own that it's rendering. 
Ah so typically when you do things like that, render functions would be more handy because um you would in a lot of cases when you so if you're using render functions are scoped slots are passed down there, uh, in a property on the instance called this.$scopedSlots, and it corresponds similar to named slots and uh, default slots. You would have this.$scopedSlots default, uh, which will be a function if it is there. Um. So you call this function and pass whatever data you would you would pass into the slot. Ah, right? So that whatever you pass into their function will be useable in the periscope as slot scope. 
And what does that scope slot function return? So it returns virtual nodes, right? Um. It returns virtual nodes, which you can then use. Uh, you can return, ah, in your render function. So you would inside, uh, a render function you would call a scope slots function, which gives you back virtual nodes. Uh, in some cases, it would it could potentially keep you back in array of nodes. But um, typically, you need to uh, can't pick just like the one node out of that array. And make sure you only return one node from your child render function, because that's you know, a limitation of stateful components are your render function is to return one node. So, uh, in most cases, uh, you would think It just like the scope slots are just functions that would give you virtual nodes back then. You can compose that either with other nodes, or you can just directly return those nodes. Yeah. And I think like what I see most commonly anyways, when someone's trying to build a component like this, the pattern generally just tends to be a render function. 
That all it does is return this. dot uh scope slot dot default passing in some computed um results. And that's kind of the whole thing. So I think like what's may be interesting to talk about a little bit here is I think a lot of people um, that use Vue don't use render functions at all because they have like this sort of idea that if I'm gonna use render functions, I should be using JSX as well. And I was one of those people until I started playing with like this. Um some of these patterns and that's when I realized that actually like render functions are still useful even if you're not using JSX because most of the time they don't have to really do anything. Right? Totally. So I'd be interested in hearing like is there anything else that's like interesting about that or what's sort of like your take on that, like using render functions without JSX so the whole point about um, JSX, I think, is just to ease the adoption of the idea of expressing HTML structures in JavaScript. 
Right? Um. So if you use react without JSX, you will be writing something like I return react.createElement h1, blah, blah, blah. And if you do this over and over again, it will be uh quite verbose. And it will, you know, probably be a big turn off to a lot of people are so JSX more or less, uh, eases that um, sort of usability gap in some sense. Uh, and it makes it, it does help a lot when you're just offering about a large chunk of static markup, right? Because you no longer uh, have to it. It also is a bridge between JavaScript, an HTML in that sense, um, but because you react, you have to use render functions everywhere. 
So that's why JSX is, uh, somewhat more, uh, more or less use more useful in that context. Because uh, anytime you need to express some HTML structure in react render functions, um, you're still dealing with JavaScript. So JSX is essentially, um, improving the right, uh, there the usability issue of writing those structures in JavaScript. Right? But in Vue, the story is a little bit different, because, um, you you're not required to use render functions everywhere. We already have templates which is closer to HTML in the first place. 
Um, so anywhere you are dealing with largely um, HTML like visual structures, um, you can already use templates. We only, uh, typically we only dropped down to into functions when you're offering some special purpose components like these, you know, uh, scoped slots components. Yeah, right. If you're offering this uh, mouse control component or some really advanced, um, logical component, uh, your logic will be implemented in JavaScript, and there's not much structure anyway. Right? Most of the logic is still just playing JavaScript. 
Uh, so it's really like JSX wouldn't really make much difference in those use cases. Anyway. Yeah, I think that's what I found interesting was when I actually needed to use a render function for something that component didn't contain like a single tag declaration anywhere because it was literally just returning the default um, slot or the default scoped slot. And what I think is interesting there that a lot of people maybe don't realize or might help bridge the gap for people as like understanding that when you're offering opponent this way and you pass in a scoped slot or even just a regular slot, these components don't need to have like that additional wrapper element that maybe like you're used to always having to have, you know what I mean, because you can just return the nodes that were passed to you directly. And now this component doesn't actually provide any new tags or anything like at all. Right? So you can think of uh, component A doesn't render any structure of its own. Instead, it just returns uh, component B yeah, It's really cool. And something that made me notice, um, which hopefully it's not just me who didn't realize this initially or who didn't think about it, is that a lot of the tags that we see in Vue, um, like in the documentation, even that that feel like special features of Vue, like the keep alive tags or transition group or the transition tag, they're not actually anything special there. They're not like special features of Vue. That Vue compiles in a special way. They're literally just plain boring components implemented with render functions, exactly like the ones that we're talking about. So I think it would be interesting maybe to hear more about sort of the underlying implementation of like the transition component, for example, like maybe that would be interesting for people to sort of understand and help uh, you know, inspire some ideas around what you can do when you take the sort of a pressure authors things. So how does the transition component actually work? 
Uh, so transition component, uh, interestingly, uh, might not be the perfect sample for this, because it does have some, uh, uh, dependency on the internal implementation. The transition component works more like an interface that we exposed to collect, uh, the hooks and the classes that you want to specify at runtime. Aha, where, uh, and also, uh, is responsible for handling the other transition modes. Um, but some lower level to a lower level access stuff like that actually deals with the DOM deals with adding and removing classes are a module in the in the lower level virtual dom. 
Um, but I can I get, um, so the transition components still is is valuable when you study like what it actually does is that um, it essentially takes whatever you give inside of it. Uh, as a normal slot. It takes a hold of that uh, elements. Virtual node the virtual node that represents that element. And then it's uh, enhances that node with some extra hooks. Ok, so and then returns that same node. Yeah, that doesn't make sense. So it's more like taking some anything that you pass to it, uh, enhance that node, and then returns the same node. So when that node gets passed to the virtual DOM engine, virtual down engine will eventually render exactly the same thing, except because of those extra hooks. Uh, the transition module in the in the virtual DOM engine knows that when this node is inserted or removed, we need to do something extra. So that's all the component is really doing. 
So am I right in saying that the transition component like could be implemented in user land? If you wanted to? Like I guess that's like the interesting thing that I'm trying to trying to get at about like some of these components that you see in Vue like uh trying to understand like is there anything special about them or are they really just interesting examples of some more creative sort of component design? Um, I would say uh the built in ones right transition and keep alive they do have some reliance on uh some special internal mechanism that make them useful. Other and that's the reason why we put them in core in the first place. If it can totally be implemented the user land we would just split them out to the individual libraries. Yeah. Right. Uh so on the other hand, if you think about um router-link and router-view in the Vue Router those are pure user land components. 
Yeah, right. So uh router-view is uh, in both router-view and router-link are also implemented using render functions and they don't rely on anything special from Vue core. They are just pure user land components. Um, so for the transition component, one of the reasons that it relies on the internal virtual DOM modules is because, um, the if you under um, you've had experience looking into Vue source. Um, the internal of Vue core is separated into a platform, agnostic runtime, uh, the core quad core, the core, uh, and uh, some platform specific code. 
So the code that actually deals with CSS classes and inserting removing DOM nodes are all inside the web platform ah, module. Yeah. So, uh, we don't want a core component to be tightly coupled to a specific platform. So the transition component really only deals with the other more abstract part of what transition means, which is interesting, because we are able to refuse the same transition component logic and hook it up to a different lower level runtime module, ah, say in Weex. So we have the same component running in Weex, but with a completely different lower level implementation at the virtual DOM level. 
Um, so that's also I think that's also the power of you know, abstract and things with components is that, um, because we're only dealing with render functions, we're only dealing with the virtual dom. We're not actually touching the real DOM in any sense. So all of these components, like the boundary of what these render functions can do, is they manipulate these abstract node tree structures. Right? That's where, uh, that's essentially the boundary of responsibility for these components. Um, you manipulate these tree structures and return them to the virtual DOM engine. And the virtual DOM engine will finally decide what to do with them. 
So I guess the disappointing side about this is that the transition component really is something special. Ah, it would be pretty difficult if you want to do it in pure user land. But um, I wouldn't say it's hundred percent impossible, but you would be you would need to be really, really familiar with how the underlying virtual DOM engine works to be able to do that. Yeah. So even still, I still think it is interesting to realize, though, that the transition component is like a component, you know, even if it does have some special magic source under the hood, um, like it still is a component that has a render function. And that's ultimately like how it works. Right? 
Yeah, the bright side. On the bright side, there's one thing you can do with the transition component is right. Um, uh, you know, it accepts a lot of props. Like you can specify what class is. It should add or remove. You can specify the time outs or special JavaScript hooks and all that. Uh, so you can write a higher order component that simply returns the transition component. Yeah. So that's actually an interesting idea that I've been thinking about that I haven't tried yet, um, but sounded interesting to me because there's certainly situations where you are trying to implement uh some sort of complex transition that can be done with just like CSS classes and you need to drop down to the JavaScript hooks level. So you can do a lot of that stuff and coming up with, I guess, patterns for making that reusable might uh, be might sound like a challenging problem to solve until you realize that you can totally just right a wrapper component for the transition component, give it like a special name. And then it gets back to like what we first started talking about, which is like that. 
That component basically just becomes like a partially applied function. Right? Exactly the transition component exactly 
[广告]
We talked about like a real basic example of like a scoped slot component. We talked a little bit about some more complicated stuff that you could do if you didn't want to render any UI or anything from the component, like a mouse tracking component or something. 
Um, are there any other examples? You can think of really interesting creative ways. You've seen people, um, design components with Vue that sort of break out of that kind of simplistic, uh, a component is a UI widget sort of model. Yeah. So, uh, one interesting example, uh, I figured out when I so I came up with this idea when I was uh, discussing with someone online. And he was showing me this language that can express and async operation directly in a procedural way. So I found that really interesting. And I was I was actually implementing scoped slots back then. And I was essentially trying to see what scoped slots could do in that case. So I implement this, uh, something like a fetch or async or await component. 
Um, so this is a component, but you give it a URL. It will, you know, send an ajax request to that your URL, and then expect you to give it a scoped slot. And this scoped slot would receive, uh, all the data regarding that request, uh, in its argument, uh, in its slot scope argument. So you would get an object that contains the current status of the request, uh, the code of the request. And, uh, if the request succeeded, the data of the request. Right? So this allows you to, so this component interestingly abstracts everything away, uh, after another, a synchronous error handling, and all the like making the request it abstract all of these things. Instead, it gives you this one object that you just then decide what to do with this object. 
So if there is an error in the object, you just render the error. If there is uh something, if it's pending, you render a pending state. If it's uh, if it has already completed, you would just use the data to render something, uh, to show to the user. So, um, express all of these logic directly in the templates. You're just using normal v-ifs like v-if ah, you've got an error, we just render an error. So now it looks quite interesting, because, um, you're not writing any JavaScript, you don't need to worry about any of the asynchronicity. Uh, in this request, you're just start using that component. And then, uh almost mechanically just writing out things that you want to see at that point of time. That's fascinating actually. So it's like it gives you like an API for sort of having just this like declarative representation of what you want. The final result to be when this data is fetched totally abstract ing away. Even the fact that it even is asynchronous or that it's gonna take some some time or anything. So that's fascinating because it's basically like it's almost like you can take any function and turn it into a component in a lot of ways. Right? 
And if you think about like a scoped slot like the slot that you pass into the component as just like a callback that you might pass to a function well then it's sort of becomes obvious that you could abstract away like an asynchronous operation that way. Yeah, that's very cool. and even Cooler part about this async component that I just talked about is I realize it's infinitely composer right? Uh even inside that uh scoped slots are of this component, you can use this component itself. Again. That's interesting. So now you have cascading requests and everything like all the edge cases are handled elegantly because uh like that part like a certain part of the template would only be rendered if the previous request has succeeded. 
Yeah. Right. So uh so I use that to implement a very complex async flow like a first. Um, you give it a username. It goes to Github API such as all the repositories that he has then goes into the repositories Figure out all the users have contributed to it. So you have the several steps of async request flow but I happen to write a single line of JavaScript you didn't ever have to write like a .then or anything. Let me just have a component you pass to the URL to get their repositories. 
And then inside of that, you have like another instance of this fetch component. I guess that's gonna go make this an API request, given the repository ID to get like the contributors. But because that component isn't even gonna render until the async operation is done, you just don't have to think about it all. Exactly. Uh, It's really cool. Yeah. is there any other examples you can think of? Sure. Uh, I think another example that's not really a scoped slot component, but more like, um, a higher order component. It could make use of scoped slots. But, um, I guess is uh, is something react16. They recently had this thing called error boundaries, right? Um. So an error boundary is essentially a mechanism that allows you to capture a error from a child component tree, and then decide how to handle that. 
Um. So in Vue, you can do exactly the same thing, ah, using this new hook that we shipped in 2.5, called error captured. So you can implement an error boundary component that's um, simply returns whatever slot is passed into it. It does nothing else, uh, but it implements this error captured hook that would capture any error that's propagated from one of its child components. Uh, and once its capture something, it will then toggle a flag in in this error boundary component itself. And when that found is flag is toggled, it would then render this error message, um, to instantly show you what error it has captured and his short circuits get the default slot that would typically not normally render. So is the idea to basically trying more gracefully handle errors so that like the rest of your app can keep working even if like something goes bad and like some isolated part. Can you think of like an example like a real world practical example that might help people understand like the power of that idea? Right? So the cool thing is er, once you implement this error boundary component, um it becomes completely reusable and adoption cost is really just like wrap whatever existing component with this error boundary component in your DOM Yeah, right? Um and the and the inside this component you can do an even more interesting things like you can do conditional handling based on production or development environment. 
Uh, if its development you would show a big red box telling you what has gone wrong in production. You might want to show a different message instead of you know bomb basking the user with other details of all this code. Yeah. Um you would show more graceful message and also at the same time maybe send something to your error tracking service to get more information about it. Yeah. That makes a lot of sense. So um, I think maybe that's like a good place to start wrapping things up, but I be curious to know maybe before we go besides like some of the stuff that we've talked about here with like scoped slots and uh that sort of stuff, are there any other interesting patterns or anything that you've seen in the community that they think people should look into and explore or projects that you think are worth like source diving into to sort of get some ideas about some of the more interesting things that you can do with Vue's component model. 
Um, so personally, for me, I actually hope that the community would consolidate around a few more flexible and uh, useful mechanism instead of uh, having very fragmented views of ways of using components. But I guess it's still really beneficial to learn about this. But I think the really if you want to get into this, I think the basic to master is really, uh, understand what's how render functions work, understand what a higher order component is, and then understand uh, what a scoped slot is in its JavaScript equivalent. I think these would really already go really far away. It could I think these would cover like 99% of your typical use cases. If you master these, it feels like to me like a component that accepts a scoped slot, uh, and is implemented with render function instead of a template like as far as like I've found that seems like the upper boundary of all you need in terms to implement like the most complex uh out of the box component ideas that you can come up with. Like so far I haven't seen like any anything that you would need to somehow go beyond that for that seems to provide like the ultimate flexibility as far as I've been able to discover. Is that align with like your experience? Yeah, totally. Uh and I think the point is that um render function is really like exposing you to the full flexibility of JavaScript and a sense right um eventually um you both be able to tap into I'll say altering how the virtual DOM diffing algorithm work. That's just simply something we don't expose. So um in that sense if you're working with Vue render functions is as close to as metal you would get. 
Yeah, right. So, uh, make, uh, in in scoped slots is the most flexible mechanism that allows you to say parenting, uh, perform component composition. So these two combine I think would um theoretically solve anything you could do. So It's like yeah, as you said, It's like the upper boundary. Awesome. Thanks so much for coming on the show again. I mean it's been a fascinating family about the stuff and I learned a lot. Yeah, you're welcome. Yeah. it's really great to have an opportunity to talk about this because uh I personally have uh have been thinking about this. But um, yeah, we haven't really seen uh, something that sort of summarize all this. I guess there are some good articles floating around. Ah, unfortunately, I have my I have haven't personally been able to, you know, uh, write something that's uh in a sense I just want to avoid uh exerting too much opinion on how things should be done, but I think it's nonetheless uh helpful to discuss it. Yeah, yeah. I think it would be cool maybe to see like a new section in the documentation or something that doesn't necessarily like teach you. This is the right way to do this and that. But maybe just something that sort of helps people expand their imagination. kind of like we've been talking about. Like here's something that you can do with components that you probably didn't realize was possible to do with components. You know and I mean like your example of like that fetch component to me is like a perfect example of something that could really get peoples sort of wheels turning thinking wow this stuff is a lot more powerful than maybe it seems at first glance. Um. Yeah. So well we have we actually had a uh working progress pull request and in our documentation on this but I think we are still are you know iterating on that. want to want to make sure that um we don't over, it's not overly opinion. They also want to make sure it's uh, actually, uh, shows the power of these mechanism properly, that, uh, you know, people can understand, actually get into it, but that's something we're already working on. Hopefully, we can have it out. awesome. 
Well, thanks again. Evan, what's the best way for people to sort of keep up with what you're doing and what sort of new in the Vue.js world if they want to keep on top of all this stuff? Um make sure to follow us on twitter and medium. Uh, most of the news that we uh new releases new stuff we would either retweet or announced on twitter first. And we also if there are some major stuff going out, we'll write blog post on medium. So these are the two main sources. And if you're more into reading the code type just I guess you can stared me on Github and look at my commits. Um, but uh sometimes I do have I have so recently I've been working on uh our new CLI but most of the commits are in a uh in an off branch so that if you're dedicated enough, you should be able to take something out of it. But we have something really cool coming up soon. Awesome. Is there anything that you want to uh, to share or plug or anything before we get going? I know there's another Vue conference coming up pretty soon. Totally. Yeah, we have actually two upcoming ones. Uh, there is one in Amsterdam. 
Uh if you're in EU definitely uh consider attending and then there's the one in US in march are in New Orleans and uh yeah the ticket sales still open, so if you haven't you know haven't already go and grab a ticket and ah I will be at both conferences and most of the Vue core team will be present at the uh become US as well. Ah you will see a lot of awesome people and we have some really great lineup, so yeah, looking forward to seeing all of you there. Awesome. Well, thanks again Evan, if anyone is interested in show notes for this episode, they can head over to uh fullstackradio.com and find them there. Thanks to robot and coach up for sponsoring the pod cast this week. And if you want to go ahead and leave us a five star review on iTunes, uh, that would be awesome. Thanks everyone, see you next time. 
